-- PRODUCTION SUPABASE CONFIGURATION\n-- Run these commands in your Supabase SQL Editor for production setup\n\n-- ============================================================================\n-- 1. AUTHENTICATION CONFIGURATION\n-- ============================================================================\n\n-- Create magic link tokens table\nCREATE TABLE IF NOT EXISTS magic_link_tokens (\n  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,\n  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,\n  email text NOT NULL,\n  token_hash text NOT NULL,\n  expires_at timestamp with time zone NOT NULL,\n  created_at timestamp with time zone DEFAULT now(),\n  used_at timestamp with time zone,\n  ip_address inet,\n  user_agent text,\n  UNIQUE(email)\n);\n\n-- Create indexes for performance\nCREATE INDEX IF NOT EXISTS idx_magic_link_tokens_email ON magic_link_tokens(email);\nCREATE INDEX IF NOT EXISTS idx_magic_link_tokens_token ON magic_link_tokens(token_hash);\nCREATE INDEX IF NOT EXISTS idx_magic_link_tokens_expires ON magic_link_tokens(expires_at);\n\n-- Enable RLS\nALTER TABLE magic_link_tokens ENABLE ROW LEVEL SECURITY;\n\n-- Create RLS policies\nDROP POLICY IF EXISTS \"Users can view their own tokens\" ON magic_link_tokens;\nCREATE POLICY \"Users can view their own tokens\" ON magic_link_tokens\n  FOR SELECT USING (auth.email() = email);\n\nDROP POLICY IF EXISTS \"Service role can manage all tokens\" ON magic_link_tokens;\nCREATE POLICY \"Service role can manage all tokens\" ON magic_link_tokens\n  FOR ALL USING (auth.role() = 'service_role');\n\n-- ============================================================================\n-- 2. MAGIC LINK GENERATION FUNCTION\n-- ============================================================================\n\nCREATE OR REPLACE FUNCTION generate_magic_link_token(user_email text)\nRETURNS json\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $$\nDECLARE\n  token_data json;\n  user_id uuid;\n  token_hash text;\n  expires_at timestamp with time zone;\nBEGIN\n  -- Validate email format\n  IF user_email !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$' THEN\n    RETURN json_build_object(\n      'success', false,\n      'error', 'Invalid email format'\n    );\n  END IF;\n  \n  -- Generate secure token (64 characters)\n  token_hash := encode(gen_random_bytes(32), 'hex');\n  expires_at := now() + interval '24 hours';\n  \n  -- Get or create user\n  SELECT id INTO user_id FROM auth.users WHERE email = user_email;\n  \n  IF user_id IS NULL THEN\n    -- Create new user with confirmed email\n    INSERT INTO auth.users (\n      instance_id,\n      id,\n      aud,\n      role,\n      email,\n      encrypted_password,\n      email_confirmed_at,\n      created_at,\n      updated_at,\n      confirmation_token,\n      email_change,\n      email_change_token_new,\n      recovery_token\n    ) VALUES (\n      '00000000-0000-0000-0000-000000000000',\n      gen_random_uuid(),\n      'authenticated',\n      'authenticated',\n      user_email,\n      crypt('', gen_salt('bf')),\n      now(), -- Auto-confirm email\n      now(),\n      now(),\n      token_hash,\n      '',\n      '',\n      ''\n    ) RETURNING id INTO user_id;\n  ELSE\n    -- Update existing user with new token\n    UPDATE auth.users \n    SET \n      confirmation_token = token_hash,\n      confirmation_sent_at = now(),\n      updated_at = now(),\n      email_confirmed_at = COALESCE(email_confirmed_at, now())\n    WHERE id = user_id;\n  END IF;\n  \n  -- Store token in custom table\n  INSERT INTO magic_link_tokens (\n    user_id,\n    email,\n    token_hash,\n    expires_at,\n    created_at\n  ) VALUES (\n    user_id,\n    user_email,\n    token_hash,\n    expires_at,\n    now()\n  ) ON CONFLICT (email) DO UPDATE SET\n    token_hash = EXCLUDED.token_hash,\n    expires_at = EXCLUDED.expires_at,\n    created_at = EXCLUDED.created_at,\n    used_at = NULL;\n  \n  RETURN json_build_object(\n    'success', true,\n    'token', token_hash,\n    'expires_at', expires_at,\n    'user_id', user_id,\n    'email', user_email\n  );\nEND;\n$$;\n\n-- ============================================================================\n-- 3. TOKEN VERIFICATION FUNCTION\n-- ============================================================================\n\nCREATE OR REPLACE FUNCTION verify_magic_link_token(token text, user_email text)\nRETURNS json\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $$\nDECLARE\n  token_record record;\n  user_record record;\n  jwt_token text;\nBEGIN\n  -- Validate inputs\n  IF token IS NULL OR user_email IS NULL OR length(token) < 32 THEN\n    RETURN json_build_object(\n      'success', false,\n      'error', 'Invalid token or email'\n    );\n  END IF;\n  \n  -- Find and validate token\n  SELECT * INTO token_record \n  FROM magic_link_tokens \n  WHERE token_hash = token \n    AND email = user_email \n    AND expires_at > now() \n    AND used_at IS NULL;\n  \n  IF NOT FOUND THEN\n    RETURN json_build_object(\n      'success', false,\n      'error', 'Invalid, expired, or already used token'\n    );\n  END IF;\n  \n  -- Mark token as used\n  UPDATE magic_link_tokens \n  SET used_at = now() \n  WHERE id = token_record.id;\n  \n  -- Get user record\n  SELECT * INTO user_record FROM auth.users WHERE id = token_record.user_id;\n  \n  IF NOT FOUND THEN\n    RETURN json_build_object(\n      'success', false,\n      'error', 'User not found'\n    );\n  END IF;\n  \n  -- Confirm user email if not already confirmed\n  UPDATE auth.users \n  SET \n    email_confirmed_at = COALESCE(email_confirmed_at, now()),\n    updated_at = now()\n  WHERE id = token_record.user_id;\n  \n  -- Generate session token (base64 encoded user data)\n  jwt_token := encode(\n    json_build_object(\n      'sub', user_record.id,\n      'email', user_record.email,\n      'iat', extract(epoch from now()),\n      'exp', extract(epoch from now() + interval '30 days'),\n      'aud', 'authenticated',\n      'role', 'authenticated'\n    )::text::bytea,\n    'base64'\n  );\n  \n  RETURN json_build_object(\n    'success', true,\n    'user', json_build_object(\n      'id', user_record.id,\n      'email', user_record.email,\n      'email_confirmed_at', user_record.email_confirmed_at\n    ),\n    'access_token', jwt_token,\n    'token_type', 'bearer',\n    'expires_in', 2592000\n  );\nEND;\n$$;\n\n-- ============================================================================\n-- 4. CLEANUP FUNCTION FOR EXPIRED TOKENS\n-- ============================================================================\n\nCREATE OR REPLACE FUNCTION cleanup_expired_tokens()\nRETURNS integer\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $$\nDECLARE\n  deleted_count integer;\nBEGIN\n  DELETE FROM magic_link_tokens \n  WHERE expires_at < now() - interval '7 days';\n  \n  GET DIAGNOSTICS deleted_count = ROW_COUNT;\n  \n  RETURN deleted_count;\nEND;\n$$;\n\n-- ============================================================================\n-- 5. GRANT PERMISSIONS\n-- ============================================================================\n\n-- Grant permissions to anon and authenticated users\nGRANT USAGE ON SCHEMA public TO anon, authenticated;\nGRANT ALL ON magic_link_tokens TO anon, authenticated;\nGRANT EXECUTE ON FUNCTION generate_magic_link_token(text) TO anon, authenticated;\nGRANT EXECUTE ON FUNCTION verify_magic_link_token(text, text) TO anon, authenticated;\nGRANT EXECUTE ON FUNCTION cleanup_expired_tokens() TO authenticated;\n\n-- ============================================================================\n-- 6. CREATE CRON JOB FOR TOKEN CLEANUP (Optional)\n-- ============================================================================\n\n-- Uncomment the following line if you have pg_cron extension enabled\n-- SELECT cron.schedule('cleanup-expired-tokens', '0 2 * * *', 'SELECT cleanup_expired_tokens();');\n\n-- ============================================================================\n-- 7. VERIFICATION QUERIES\n-- ============================================================================\n\n-- Test the functions (run these to verify setup)\n-- SELECT generate_magic_link_token('test@example.com');\n-- SELECT verify_magic_link_token('test_token', 'test@example.com');\n-- SELECT cleanup_expired_tokens();\n\n-- Check table structure\n-- SELECT * FROM information_schema.tables WHERE table_name = 'magic_link_tokens';\n-- SELECT * FROM information_schema.routines WHERE routine_name LIKE '%magic_link%';\n\n-- ============================================================================\n-- 8. PRODUCTION NOTES\n-- ============================================================================\n\n/*\nIMPORTANT PRODUCTION SETTINGS:\n\n1. Supabase Dashboard > Authentication > Settings:\n   - Enable email confirmations: OFF\n   - Enable email change confirmations: OFF\n   - Site URL: https://testingvala.com\n   - Additional redirect URLs:\n     * https://testingvala.com/auth/verify\n     * https://testingvala-admin-user.vercel.app/auth/verify\n\n2. Supabase Dashboard > Authentication > URL Configuration:\n   - Site URL: https://testingvala.com\n   - Redirect URLs: Add all production URLs\n\n3. Environment Variables (Vercel):\n   - VITE_SUPABASE_URL: Your Supabase project URL\n   - VITE_SUPABASE_ANON_KEY: Your Supabase anon key\n   - ZEPTO_API_KEY: Your ZeptoMail API key\n   - ZEPTO_FROM_EMAIL: info@testingvala.com\n   - ZEPTO_FROM_NAME: TestingVala\n\n4. ZeptoMail Configuration:\n   - Sandbox mode: DISABLED\n   - Domain verification: COMPLETED for testingvala.com\n   - DNS records: SPF, DKIM, DMARC configured\n\n5. Security Considerations:\n   - Tokens expire after 24 hours\n   - Each token can only be used once\n   - RLS policies protect user data\n   - Regular cleanup of expired tokens\n*/\n